Writeup for ECC2:

We are given a few parameters for an elliptic curve (call it E). The curve is standard form (y^2 = x^3 + A*x + B mod M), where M = 93556643250795678718734474880013829509320385402690660619699653921022012489089, A = 66001598144012865876674115570268990806314506711104521036747533612798434904785. We are also given a point P = (56027910981442853390816693056740903416379421186644480759538594137486160388926, 65533262933617146434438829354623658858649726233622196512439589744498050226926) on E, and another point Q=n*P=(74647214391681695738591854514827282776284320657533011866635380911179062421057, 82529108655687512582506167549818063506654449859068362362992611609979624419700) obtained from point multiplication over the curve. First, to find B, all we need to do is plug in our values of X and Y for P and solve for B.

B = 65533262933617146434438829354623658858649726233622196512439589744498050226926^2 - 56027910981442853390816693056740903416379421186644480759538594137486160388926^3 - 66001598144012865876674115570268990806314506711104521036747533612798434904785*56027910981442853390816693056740903416379421186644480759538594137486160388926 mod 93556643250795678718734474880013829509320385402690660619699653921022012489089
= 25255205054024371783896605039267101837972419055969636393425590261926131199030

In Sage, E = EllipticCurve(GF(93556643250795678718734474880013829509320385402690660619699653921022012489089), [66001598144012865876674115570268990806314506711104521036747533612798434904785, 25255205054024371783896605039267101837972419055969636393425590261926131199030]).

Now that we have B (and so we have the complete description of E), the difficult part is solving the elliptic curve discrete log problem to find n given Q=n*P and P. This is precisely what gives ECC its security, since generally we would have to brute force n over the order of P (the number of points which can be produced from P using point multiplication), which is 93556643250795678718734474880013829509196181230338248789325711173791286325820 (E.order() in Sage). This certainly wouldn't be feasible in the time we had available. Thankfully, we are also given a constraint: n < 400000000000000000000000000000. While this is still not feasible to brute force, it's possible to massively improve our search because of this constraint.

The main improvement comes because the group E's order is nonprime. As we determined using sage before (E.order()), the order of E is 93556643250795678718734474880013829509196181230338248789325711173791286325820, which factors easily to 2^2 · 3 · 5 · 7 · 137 · 593 · 24337 · 25589 · 3637793 · 5733569 · 106831998530025000830453 · 1975901744727669147699767. By applying the Pohlig-Hellman algorithm, we can then see that the worst-case time complexity is only the square root of the largest prime factor of the order, which is 1405667722019. While this is certainly an improvement, we can do better. Because of the constraint on n, we know that n will not have a prime factor greater than sqrt(400000000000000000000000000000), which is 632455532033675. Thus, for Pohlig-Hellman we can disregard the two largest factors of the order 106831998530025000830453 and 1975901744727669147699767, using only the factors 2^2 · 3 · 5 · 7 · 137 · 593 · 24337 · 25589 · 3637793 · 5733569. We now have a much better time complexity on the order of sqrt(5733569), or about 2394. After implementing Pohlig-Hellman in Sage (using the code from http://wstein.org/edu/2010/414/projects/novotney.pdf), and forcing this easier factor list, we get n=235905436253193650898119413136.

E = EllipticCurve(GF(93556643250795678718734474880013829509320385402690660619699653921022012489089), [66001598144012865876674115570268990806314506711104521036747533612798434904785, 25255205054024371783896605039267101837972419055969636393425590261926131199030])

def PolligHellman(P,Q):
    zList = list()
    conjList = list()
    rootList = list()
    n = P.order()
    factorList = ((2,2), (3,1), (5,1), (7,1), (137, 1), (593, 1), (24337, 1), (25589, 1), (3637793, 1), (5733569, 1))
    for facTuple in factorList:
        P0 = (ZZ(n/facTuple[0]))*P
        conjList.append(0)
        rootList.append(facTuple[0]^facTuple[1])
        for i in range(facTuple[1]):
            print (facTuple[0], i, zList)
            Qpart = Q
            for j in range(1,i+1):
                Qpart = Qpart - (zList[j-1]*(facTuple[0]^(j-1))*P)
            Qi = (ZZ(n/(facTuple[0]^(i+1))))*Qpart
            zList.insert(i,discrete_log(Qi,P0,operation='+'))
        conjList[-1] = conjList[-1] + zList[i]*(facTuple[0]^i)
    return crt(conjList,rootList)

P = E(56027910981442853390816693056740903416379421186644480759538594137486160388926, 65533262933617146434438829354623658858649726233622196512439589744498050226926)
Q = E(74647214391681695738591854514827282776284320657533011866635380911179062421057, 82529108655687512582506167549818063506654449859068362362992611609979624419700)
print PolligHellman(P,Q)

"""
(2, 0, [])
(2, 1, [0])
(3, 0, [0, 0])
(5, 0, [2, 0, 0])
(7, 0, [1, 2, 0, 0])
(137, 0, [0, 1, 2, 0, 0])
(593, 0, [76, 0, 1, 2, 0, 0])
(24337, 0, [203, 76, 0, 1, 2, 0, 0])
(25589, 0, [17985, 203, 76, 0, 1, 2, 0, 0])
(3637793, 0, [3161, 17985, 203, 76, 0, 1, 2, 0, 0])
(5733569, 0, [69906, 3161, 17985, 203, 76, 0, 1, 2, 0, 0])
235905436253193650898119413136
"""

To confirm:

print 235905436253193650898119413136 * P

(74647214391681695738591854514827282776284320657533011866635380911179062421057 : 82529108655687512582506167549818063506654449859068362362992611609979624419700 : 1)

Which is Q.
